---
title: "figs_tabs_results"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Possible palettes #1: #538797, #C2D9CD, #FF842A https://www.instagram.com/p/B9En6h2gbJ5/
#Possible palette #2: #238189, #3FA8B3, #E8F3EE, #FF674D https://www.instagram.com/p/BxZZu82gBm3/


#File structure
rootdir <- rprojroot::find_root(rprojroot::has_dir("src")) 
srcdir <- file.path(rootdir, 'src', 'globalIRmap')
datdir <- file.path(rootdir, 'data')
resdir <- file.path(rootdir, 'results')

#Source packages functions
library(drake)
source(file.path(srcdir, 'R/IRmapping_packages.R'))
source(file.path(srcdir, 'R/IRmapping_functions.R'))
source(file.path(srcdir, 'R/IRmapping_plan.R'))

#Get packages
library("rnaturalearth")
library("rnaturalearthdata")
library(rgeos)
library(rgdal)
library(gstat)
library(raster)
library(cowplot)
library(maps)
library(patchwork)
#remotes::install_github("zeehio/facetscales")
library(facetscales)
library(scales)
library(kableExtra)
library(viridis)

#Define paths
riveratlas_path <- file.path(datdir, 'HydroATLAS', 
                             'RiverATLAS_v10.gdb', 'RiverATLAS_v10') 

bufras_vec <- file.path(resdir, 'bufrasdir',
                        grep('bufras_T[0-9]{1-3}proj[.]tif$', 
                             list.files(file.path(resdir, 'bufrasdir')),
                             value=T))

#Source analysis outputs
cached()
history_last <- drake_history(analyze = TRUE) %>%
  setDT %>%
  .[, built := as_datetime(built)] %>%
  setorder(built) %>%
  .[, .SD[.N,], by=target]

cache <- drake_cache()
rfbm_regr<- cache$get_value(history_last[target=='rfbm_regr',hash])
rfbm_classif<- cache$get_value(history_last[target=='rfbm_classif',hash])
bmcheck_classif <- cache$get_value(history_last[target=='bm_checked_rfbm_classif.bm_classif_rfbm_classif.measure_classif', hash])
bmcheck_regr<- cache$get_value(history_last[target=='bm_checked_rfbm_regr.bm_regr_rfbm_regr.meassure_regr', hash])
rfeval_featsel <- cache$get_value(history_last[target=='rfeval_featsel',hash])
rftuned <- cache$get_value(history_last[target=='rftuned',hash])

loadd(predvars)
loadd(filestructure)
loadd(gaugestats_format)

#Define Winkel Tripel projection
crs_wintri = "+proj=wintri +datum=WGS84 +no_defs +over"

#Get mapping basemaps
wcountries <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf")
wland <- rnaturalearth::ne_download(scale = 110, type = 'land', category = 'physical')
wlakes <- rnaturalearth::ne_download(scale = 110, type = 'lakes', category = 'physical')

sfformat_wintri <- function(in_sp) {
  return(st_as_sf(in_sp) %>%
           st_transform("+proj=wintri", use_gdal = FALSE)
)
}

#Create winkel tripel graticule
grat_wintri <- 
  st_graticule(lat = c(-89.9, seq(-80, 80, 20), 89.9)) %>%
  st_transform(crs = crs_wintri)

#---- Import and format river network lines, keeping a subset of columns and only for river orders > 4 --------
# riv_query <- "SELECT HYRIV_ID, ORD_STRA, dis_m3_pyr FROM \"RiverATLAS_v10\" WHERE ORD_STRA > 4"
# riv_lines <- st_read(dsn = dirname(riveratlas_path), 
#                       layer = basename(riveratlas_path),
#                       query = riv_query)
# 
# riv_wintri <- sfformat_wintri(riv_lines)
# riv_simple <-  sf::st_simplify(riv_wintri, preserveTopology = TRUE, dTolerance = 1000)

#---- Import and format streamgauges --------
gaugepred <- st_read(filestructure['out_gauge']) %>%
  sfformat_wintri

#---- Import and format river network attributes ------------------------------
cols_tokeep <-  c("HYRIV_ID", predvars[!is.na(ID),varcode],
                  'ele_mt_cav','ele_mt_uav', 'gwt_cm_cav', 'ORD_STRA',
                  paste0('pre_mm_c', str_pad(1:12, width=2, side='left', pad=0)),
                  paste0('cmi_ix_c', str_pad(1:12, width=2, side='left', pad=0)),
                  paste0('swc_pc_c', str_pad(1:12, width=2, side='left', pad=0)))

riveratlas <- fread_cols(filestructure['in_riveratlas'], 
                         cols_tokeep = cols_tokeep) %>%
  comp_derivedvar

```


#Main text - Figure 1. Geographical distribution of reference streamgauging stations
```{r basic map, echo = FALSE, fig.width = 6,  dpi=300}
ggrivers <- function() {
    ggplot() +
    geom_sf(data = grat_wintri, color = alpha("black", 1/5), size = 0.25/.pt) + 
    geom_sf(data=sfformat_wintri(wland), alpha=1/2, color=NA) +
    geom_sf(data=sfformat_wintri(wlakes),  alpha=1/3, fill='black', color=NA) +
    # geom_sf(data=riv_simple[riv_simple$ORD_STRA < 6,][1:10000,],
    #         aes(size=ORD_STRA), color=alpha('black', 1/20), show.legend = F) +
    # geom_sf(data=riv_simple[riv_simple$ORD_STRA >= 6,][1:10000,],
    #         aes(size=ORD_STRA), color=alpha('black', 1/10), show.legend = F) +
    scale_size_continuous(range=c(0.2, 1.0)) +
    coord_sf(datum = NA, expand=F,
             xlim=c(-16500000, 16500000), ylim=c(-7000000,8700000)) +
    theme_map() + 
    theme(legend.position=c(0.1,0),
          legend.direction="horizontal",
          legend.text = element_text(size=12),
          legend.title = element_text(size=12),
          legend.key.height = unit(0.1,"in"))
}

perennial_gauges <- gaugepred[gaugepred$intermittent=='0',]
p_pr <- ggrivers() + 
  geom_sf(data=perennial_gauges, aes(color=totalYears_kept), size=1, alpha=0.8) +
  scale_color_gradient(name='Years of data', low='#0F9FD6', high='#152540', 
                       breaks=c(min(perennial_gauges$totalYears_kept), 100 , 
                                max(perennial_gauges$totalYears_kept))) +
  coord_sf(datum = NA, expand=F,
           xlim=c(-17000000, 17000000), ylim=c(-7000000,8700000))

ir_gauges <-  gaugepred[gaugepred$intermittent=='1',]
p_ir <- ggrivers() + 
  geom_sf(data=ir_gauges, aes(color=totalYears_kept), size=1, alpha=0.8) +
  scale_color_gradient(name='Years of data', low='#ff9b52', high='#a32d18', 
                       breaks=c(min(ir_gauges$totalYears_kept), 100, 
                                max(ir_gauges$totalYears_kept))) +
    coord_sf(datum = NA, expand=F,
             xlim=c(-17000000, 17000000), ylim=c(-7000000,8700000))

p_pr/p_ir

```

#Methods - Table 1. Environmental variables used in model training  + variable selection results
```{r variable figure, echo=FALSE } 
predvars[varcode=='dis_mm_pvar', `:=`(
  Category = 'Hydrology',
  Attribute= 'Natural Discharge',
  `Spatial representation`='p',
  `Temporal/Statistical aggreg.`='mn/mx',
  Source = 'WaterGAP v2.2',
  Citation = 'Döll et al. 2003'
)]

predvars[varcode=='dis_mm_pvaryr', `:=`(
  Category = 'Hydrology',
  Attribute= 'Natural Discharge',
  `Spatial representation`='p',
  `Temporal/Statistical aggreg.`='mn/yr',
  Source = 'WaterGAP v2.2',
  Citation = 'Döll et al. 2003'
)]

predvars[varcode=='ele_pc_rel', `:=`(
  Category = 'Physiography',
  Attribute= 'Elevation',
  `Spatial representation`='c',
  `Temporal/Statistical aggreg.`='(cav-uav)/uav',
  Source = 'EarthEnv-DEM90',
  Citation = 'Robinson et al. 2014'
)]


predvars[varcode=='pre_mm_cvar', `:=`(
  Category = 'Climate',
  Attribute= 'Precipitation',
  `Spatial representation`='c',
  `Temporal/Statistical aggreg.`='mn/mx',
  Source = 'WorldClim v1.4',
  Citation = 'Hijmans et al. 2005'
)]

oldcolnames <- c('Spatial.representation',
                 'Temporal.or.statistical.aggregation.or.other.association',
                 'Source Data')
newcolnames <- c('Spatial representation',
             'Temporal/Statistical aggreg.',
             'Source')

predvars_format <- copy(predvars) %>%
  setnames(oldcolnames, newcolnames) %>%
  setorder(Category, Attribute, 
           `Spatial representation`, `Temporal/Statistical aggreg.`)

######## ADD variable importance, ranking, and p-value#######################################
#loadd(rfeval_featsel)
#bm_classif$vimp
#predvars_format <- merge(predvars_format, predvars_format, by.x= 'varcode', by.y='varnames']


kable(predvars_format[,c('Category', 'Attribute', 
                         newcolnames, 'Citation'), with=F]) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

#Methods - Figure 1. Environmental distribution of reference streamgauging stations
Bernhard, is dor_pc_pva x 100 rather than x10 (as written in doc)?
```{r envdistrib, fig.width = 6, fig.height=6, dpi=300, message=FALSE}
#Radar plot of selected variables
#names(riveratlas)

varstoplot_hist <- c("ari_ix_uav", "cly_pc_uav", "clz_cl_cmj", "cmi_ix_uyr", 
                      "dis_m3_pyr", "dor_pc_pva","for_pc_use", "gla_pc_use", 
                     "kar_pc_use", "lka_pc_use", "pet_mm_uyr", "snw_pc_uyr", 
                     "run_mm_cyr", "swc_pc_uyr", "tmp_dc_uyr", "hdi_ix_cav",
                     "hft_ix_c93", "ORD_STRA", "gwt_m_cav",  "ire_pc_use")

formatscales <- function(in_df, varstoplot) {
  scales_x <- list(
    ari_ix_uav = scale_x_continuous(),
    cly_pc_uav = scale_x_continuous(labels=percent_format(scale=1)),
    clz_cl_cmj = scale_x_continuous(limits=c(1,18), expand=c(0,0),
                                    breaks=seq(0,18,2)),
    cmi_ix_uyr = scale_x_continuous(),
    dis_m3_pmn = scale_x_sqrt(breaks=c(0, 10^(0:log10(max(in_df$dis_m3_pmn)))),
                              labels=c(0, 10^(0:log10(max(in_df$dis_m3_pmn))))),
    dis_m3_pyr = scale_x_sqrt(breaks=c(0, 10^(0:log10(max(in_df$dis_m3_pmn)))),
                              labels=c(0, 10^(0:log10(max(in_df$dis_m3_pmn))))),
    dor_pc_pva = scale_x_continuous(labels=percent_format(scale=1)),
    for_pc_use = scale_x_continuous(labels=percent_format(scale=1)),
    gla_pc_use = scale_x_continuous(labels=percent_format(scale=1)),
    gwt_m_cav = scale_x_continuous(), #Change that to gwt_m_cav
    inu_pc_umn = scale_x_continuous(labels=percent_format(scale=1)),
    ire_pc_use = scale_x_continuous(labels=percent_format(scale=1)),
    kar_pc_use = scale_x_continuous(labels=percent_format(scale=1)),
    lka_pc_use = scale_x_continuous(labels=percent_format(scale=1)),
    pet_mm_uyr = scale_x_continuous(), 
    snw_pc_uyr = scale_x_continuous(labels=percent_format(scale=1)),
    run_mm_cyr = scale_x_continuous(),
    swc_pc_uyr = scale_x_continuous(labels=percent_format(scale=1)),
    tmp_dc_uyr = scale_x_continuous(),
    hdi_ix_cav = scale_x_continuous(),
    hft_ix_c09 = scale_x_continuous(),
    ORD_STRA = scale_x_continuous()
  ) %>%
    .[(names(.) %in% names(in_df)) & names(.) %in% varstoplot] 
  #Only keep those variables that are actually in df and that we want to plot
  
  scales_y <- unlist(rep(list(scale_y_log10(expand=c(0,0))), labels = scientific_format(),
                         length(scales_x)), 
                     recursive=F) %>%
    setNames(names(scales_x))
  scales_y[['dis_m3_pmn']] <- scale_y_sqrt(expand=c(0,0))
  
  coordcart <- lapply(varstoplot_hist, function(var) {
    coord_cartesian(xlim=as.data.table(in_df)[, c(min(get(var)), max(get(var)))])
  }) %>%
    setNames(names(scales_x))
  
  coordcart[['clz_cl_cmj']] <-  coord_cartesian(
    xlim=c(1,max(in_df$clz_cl_cmj)))
  
  
  return(list(scales_x=scales_x, scales_y=scales_y, coordcart=coordcart))
}

scalesenvhist <- formatscales(in_df=riveratlas, varstoplot=varstoplot_hist)


ggenvhist <- function(vartoplot, in_gaugedt, in_rivdt, in_predvars, intermittent=TRUE) {
  print(vartoplot)
  if (intermittent) {
    vartoplot2 <- c(vartoplot, 'intermittent')
  }
  
  varname <- in_predvars[varcode==vartoplot, paste0(Attribute, ' ', 
                                                    Keyscale, 
                                                    Keystat, 
                                                    ' (',unit,')')]
  gaugeformat <- as.data.table(in_gaugedt)[, `:=`(
    ari_ix_cav = ari_ix_cav/100,
    ari_ix_uav = ari_ix_uav/100,
    cmi_ix_cmn = cmi_ix_cmn/100,
    cmi_ix_uyr = cmi_ix_uyr/100,
    dor_pc_pva = dor_pc_pva/100,
    lka_pc_cse = lka_pc_cse/10,
    lka_pc_use = lka_pc_use/10,
    tmp_dc_cmn =  tmp_dc_cmn/10,
    tmp_dc_cmx =  tmp_dc_cmx/10,
    tmp_dc_cyr =  tmp_dc_cyr/10,
    tmp_dc_uyr =  tmp_dc_uyr/10,
    gwt_m_cav = gwt_cm_cav/100
  )] %>%
    .[, vartoplot2, with=F] 
  
  rivformat <- as.data.table(in_rivdt)[, vartoplot, with=F]
  
  penvhist <- ggplot(gaugeformat, aes_string(x=vartoplot)) +
    geom_histogram(data=rivformat, bins=20, fill='lightgray') + 
    geom_histogram(bins=20, fill='darkgray') +
    #aes(fill=intermittent), position = 'stack') - doesn't work with log or sqrt y scale
    # scale_fill_manual(values=c('#0F9FD6','#ff9b52'), 
    #                   labels = c('Perennial', 'Intermittent'), name=NULL) +
    scalesenvhist$scales_x[[vartoplot]] +
    scalesenvhist$scales_y[[vartoplot]] +
    scalesenvhist$coordcart[[vartoplot]] +
    xlab(varname) +
    ylab('Count') +
    theme_classic() + 
    theme(strip.background=element_rect(colour="white", fill='lightgray'),
          axis.title.y = element_blank(),
          axis.title = element_text(size=12))
  

  if (which(vartoplot %in% varstoplot_hist)!=length(varstoplot_hist)) {
    penvhist <- penvhist + 
      theme(legend.position='none')
  }

  return(ggplotGrob(penvhist)) 
}

penvhist_grobs <- lapply(varstoplot_hist, ggenvhist, 
                         in_gaugedt = gaugepred, 
                         in_rivdt = riveratlas,
                         in_predvars=predvars)
do.call("grid.arrange", list(grobs=penvhist_grobs))
```


#Methods - Table 2. Specification and benchmark comparison of models
```{r models benchmarking table, echo=FALSE}
rsmp_bbrier <- function(bmres, rsmp_i) {
  rsmp <- bmres$resample_result(rsmp_i)
  rsmp_pred<- rsmp$prediction()
  if (inherits(rsmp_pred, 'PredictionClassif')) {
    bbrier <- sum((as.numeric(as.character(rsmp_pred$truth)) -
                     rsmp_pred$prob[,'1'])^2)/length(rsmp_pred$row_ids)
  }

  if (inherits(rsmp_pred, 'PredictionRegr')) {
    bbrier <- sum((as.numeric(as.character(rsmp_pred$truth)) -
                     rsmp_pred$response)^2)/length(rsmp_pred$row_ids)
  }
  return(bbrier)
}

rsmp_auc <- function(bmres, rsmp_i) {
  rsmp <- bmres$resample_result(rsmp_i)
  rsmp_pred<- rsmp$prediction()
  auc <- Metrics::auc(rsmp_pred$truth, rsmp_pred$response)
  return(auc)
}

rsmp_bacc <- function(bmres, rsmp_i, threshold_class) {
  rsmp <- bmres$resample_result(rsmp_i)
  rsmp_pred <- rsmp$prediction()

  if (inherits(rsmp_pred, 'PredictionClassif')) {
    prob_resp <- rsmp_pred$prob[,'1']
  }
  
  if (inherits(rsmp_pred, 'PredictionRegr')) {
    prob_resp <- rsmp_pred$response
  }

  response <- as.data.table(prob_resp)[
    , c(fifelse(prob_resp>=threshold_class, '1', '0'))]

  bacc <- mlr3measures::bacc(factor(as.character(rsmp_pred$truth),
                                    levels=c('0', '1')),
                             factor(response, levels=c('0','1')))
  return(data.table(bacc=bacc, threshold_class=threshold_class))
}

bm_paramstime <- function(bmres) {
  lrns_dt <- as.data.table(bmres$data)

  ##############################################################################
  params_format <- lapply(lrns_dt$learner, function(lrn) {
    print(lrn$id)
    #Get general parameters-----------------------------------------------------
    if (inherits(lrn ,'AutoTuner')) {
      lrn_in <- lrn$learner
    } else {
      lrn_in <- lrn
    }

    #If GraphLearner, get parameters for each Pipe Operator
    if (inherits(lrn_in, 'GraphLearner')) {
      paramtab <- lapply(lrn_in$graph$pipeops, function(po) {
        #Get default params
        def <- as.data.table(po$param_set$default) %>%
          .[, po_id := po$id] %>%
          melt(id.var='po_id')

        #Get set param
        value <- as.data.table(po$param_set$values) %>%
          .[, po_id := po$id]%>%
          melt(id.var='po_id')

        #Merge default and set params, keeping set ones when present
        if (ncol(def)==1) {
          tabmerge <- value
        } else if (ncol(value)==1) {
          tabmerge <- def
        } else {
          tabmerge <- merge(def, value[, .(variable, value, po_id)],
                               by=c('po_id', 'variable'),
                               all.x=T, all.y=T) %>%
            .[is.na(value.y), value.y := value.x] %>%
            setnames('value.y', 'value') %>%
            .[, value.x := NULL] 
        }
        
          graphparams <- tabmerge %>%
            .[, variable := gsub('[.]', '', variable)] %>%
            unique(by='variable')
          
        return(graphparams)
      }) %>%
        rbindlist(use.names=TRUE)

    #If direct learner
    } else {
      #Get default params
      def <- as.data.table(lrn_in$param_set$default) %>%
        melt(id.vars=integer())

      #Get set param
      value <- as.data.table(lrn_in$param_set$values) %>%
        melt(id.vars=integer())
      
      if (def[,.N]>0 & value[,.N]>0) {
        tabmerge <- merge(def, value, by='variable', all.x=T, all.y=T)%>%
          .[is.na(value.y), value.y := value.x] %>%
          setnames('value.y', 'value') %>%
          .[, value.x := NULL] 
      } else {
        tabmerge <- rbind(def, value)
      }
      
      #Merge default and set params, keeping set ones when present
      paramtab <- tabmerge %>%
        .[, variable := gsub('[.]', '', variable)] %>%
        unique(by='variable') #Models are not consistent in their use of dots
    }

    #Get inner sampling parameters----------------------------------------------
    if ('instance_args' %in% names(lrn)) {
      param_ranges <- as.list(
        paste0(lrn$instance_args$param_set$lower,
               '-',
               lrn$instance_args$param_set$upper))
      names(param_ranges) <- lrn$instance_args$param_set$ids()


      inner_smp  <- cbind(
        as.data.table(
          lrn$instance_args$resampling$param_set$get_values()),
        as.data.table(
          lrn$instance_args$terminator$param_set$get_values())
      ) %>%
        .[, nruns := prod(.SD)] %>%
        setnames(names(.), paste0('inner_', names(.))) %>%
        cbind(as.data.table(param_ranges))

      #If no inner sampling
    } else {
      inner_smp <- data.table(inner_nruns = 1)
    }


    #Remove pipe operator names and dot from names (inconsistent use across learners)
    setnames(inner_smp,
             old=names(inner_smp),
             new=gsub('[.]', '',
                      gsub(paste(paste0('(', unique(paramtab$po_id), '[.]*)'),
                                 collapse = '|'),
                           '',
                           names(inner_smp))))

    #---------------------------------------------------------------------------
    #Merge inner sampling parameters and general parameters, then format
    return(
      paramtab %>%
      .[!(variable %in% names(inner_smp)),] %>%
      dcast(.~variable, value.var='value') %>%
      cbind(inner_smp)
    )
  }) %>%
    rbindlist(., fill=T)
  ##############################################################################

  #Get task, learner and resampling ids
  lrns_time <- cbind(lrns_dt, params_format) %>%
    .[, learner_id := unlist(lapply(learner, function(x) x$id))] %>%
    .[, task_id := unlist(lapply(task, function(x) x$id))] %>%
    .[, resampling_id := unlist(lapply(resampling, function(x) x$id))]
  
  #Get number of features
  lrns_time[, npredictors := 
              lapply(lrns_dt$task,function(x) length(x$feature_names)) %>%
              unlist] 
  
  #Compute train and predict time by learner, task and resampling
  bm_ttot <- as.data.table(bmres$aggregate(list(msr('time_train'),
                                                msr('time_predict')))) %>%
    .[lrns_time, on=c('learner_id', 'task_id', 'resampling_id')] %>%
    unique(by='nr') %>%
    .[, time_train := time_train/inner_nruns]

  return(bm_ttot)
}

bm_msrtab <- function(bmres) {
  bbrier_vec <- lapply(1:bmres$n_resample_results, function(i) {
    rsmp_bbrier(bmres=bmres, rsmp_i=i)
  }) %>%
    unlist

  auc_vec <- lapply(1:bmres$n_resample_results, function(i) {
    rsmp_auc(bmres=bmres, rsmp_i=i)
  }) %>%
    unlist

  outer_smp <- lapply(bmres$resamplings$resampling, function(rsmp_design) {
    as.data.table(rsmp_design$param_set$get_values()) %>%
      setnames(names(.), paste0('outer_', names(.))) %>%
      .[, resampling_id := rsmp_design$id]
  }) %>%
    rbindlist(use.names=T)

  bacc_vec <- lapply(1:bmres$n_resample_results, function(i) {
    baccthresh <- ldply(seq(0,1,0.01), function(threshold_class) {
      rsmp_bacc(bmres, rsmp_i=i, threshold_class=threshold_class)}) %>%
      setorder(bacc) %>%
      setDT %>%
      .[, .SD[.N, .(bacc, threshold_class)]]
  }) %>%
    rbindlist

  #Get inner sampling params, general params, and time
  params_time_dt <- bm_paramstime(bmres)

  #Get time and add to bbrier
  moddt <- bm_paramstime(bmres) %>%
    cbind(., outer_smp) %>%
    cbind(., bacc_vec) %>%
    .[,`:=`(bbrier = bbrier_vec,
            auc = auc_vec)]

  return(moddt)
}

format_modelcompdat <- function(bmres, typecomp=c('classif1', 'regr1', 'classif2')) {
  if (typecomp == 'classif1') {
    bmres[, `:=`(selection = 'Algorithm',
                 type = 'Classif.')]  %>%
      .[, learner_format := dplyr::case_when(
        learner_id == 'classif.ranger.tuned'~'default RF',
        learner_id == 'oversample.classif.ranger.tuned'~'default RF-oversampled',
        learner_id == 'classweights.classif.ranger.tuned'~'default RF-weighted classes',
        learner_id == 'classif.cforest'~'CIF',
        learner_id == 'oversample.classif.cforest'~'CIF-oversampled',
        learner_id == 'classweights.classif.cforest'~'CIF-weighted classes',
      )]
    
  } else if (typecomp == 'regr1') {
    bmres[, `:=`(selection = 'Algorithm',
                 type = 'Regr.')] %>%
      .[, learner_format := dplyr::case_when(
        task_id == 'inter_regr' ~'MAXSTAT',
        task_id == 'inter_regrover' ~'MAXSTAT-oversampled'
      )]
    
  } else if (typecomp == 'classif2') {
    bmres[, `:=`(selection = 'Predictors',
                 type = 'Classif.')] %>%
      .[, learner_format := dplyr::case_when(
        task_id == 'inter_basicsp' ~ 'default RF-oversampled-all variables',
        task_id == 'inter_basicsp_featsel' ~ 'default RF-oversampled-selected variables'
      )]
  } else {
    stop('typecomp is not recognized')
  }
}

tbbrier_classif1 <- bm_msrtab(rfbm_classif$bm_classif) %>%
  format_modelcompdat('classif1')

tbbrier_regr1 <- bm_msrtab(rfbm_regr$bm_regr)  %>%
  format_modelcompdat('regr1')

tbbrier_classif2 <- bm_msrtab(rfeval_featsel$bm_classif)  %>%
  format_modelcompdat('classif2')

metrics_dat <- rbindlist(list(tbbrier_classif1, tbbrier_regr1, tbbrier_classif2),
                         fill = TRUE, use.names = TRUE)

#Continue formatting table
metrics_dat[is.na(ntree), ntree := numtrees]
metrics_dat[is.na(fraction), fraction := samplefraction]
metrics_dat[, `minor_weight|ratio` := fifelse(is.na(minor_weight), 
                                              ratio, minor_weight)]


#Create model specification tables
setup_table <- metrics_dat[, .(selection, type, learner_format, 
                               inner_folds, inner_n_evals,
                               alpha, mtry, minnodesize, fraction, 
                               `minor_weight|ratio`, npredictors, 
                               outer_repeats, outer_folds)] %>%
  .[!grepl('(CIF)|(MAXSTAT)', learner_format), alpha := NA] %>%
  .[grepl('MAXSTAT', learner_format), minnodesize := NA] %>%
  unique(by='learner_format')

kable(setup_table) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

#Create model results table
results_table <- metrics_dat[, .(selection, learner_format, 
                                 resampling_id, outer_repeats, outer_folds,
                                 time_train=round(time_train),
                                 time_predict=round(time_predict),
                                 bacc=round(bacc, 3), threshold_class, 
                                 bbrier=round(bbrier, 3), auc=round(auc, 3)
                                 )]

kable(results_table) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

#Methods - Figure 2. Benchmark comparison of models through curves
```{r models benchmarking curves, echo=FALSE}
threshold_dat <- function(bmres) {
  bmres_dt <- as.data.table(bmres) %>%
    .[, learner_id := unlist(lapply(learner, function(x) x$id))] %>%
    .[, task_id := unlist(lapply(task, function(x) x$id))] %>%
    .[, resampling_id := unlist(lapply(resampling, function(x) x$id))] %>%
    unique(by='uhash')

  if (bmres$task_type == 'regr') {
    preds <- lapply(seq_len(bmres_dt[,.N]), function(rsmp_i) {
      preds <- bmres_dt$prediction[[rsmp_i]]$test %>%
        as.data.table %>%
        .[, `:=`(outf = bmres_dt$iteration[[rsmp_i]],
                 task = bmres_dt$task[[rsmp_i]]$id,
                 task_type = bmres$task_type,
                 learner = bmres_dt$learner[[rsmp_i]]$id)]
      return(preds)
    }) %>%
      do.call(rbind, .)

    if (!('prob.1' %in% names(preds)) & 'response' %in% names(preds)) {
      preds[, prob.1 := response]
    }
  }

  outtab <- lapply(1:bmres$n_resample_results, function(rsmp_i) {
    print(rsmp_i)
    rsmp_preds <- bmres$resample_result(rsmp_i)$prediction()

    if (bmres$task_type == 'regr') {
      rsmp_preds <- preds
    }

    baccthresh <- ldply(seq(0,1,0.01), function(threshold_class) {
      print(threshold_class)
      cbind(
        rsmp_bacc(bmres, rsmp_i=rsmp_i, threshold_class=threshold_class),
        threshold_misclass(i=threshold_class, in_preds=rsmp_preds)
      ) %>%
        .[, i:=NULL]
    }) %>%
      setDT %>%
      cbind(bmres_dt[rsmp_i, .(learner_id, task_id, resampling_id)])
    return(baccthresh)
  }) %>%
    rbindlist


  outtab_melt <- melt(outtab, id.vars=c('threshold_class',
                                        'learner_id', 'task_id', 'resampling_id'))
  return(outtab_melt)
}

thresh_classif1 <- threshold_dat(bmres = rfbm_classif$bm_classif)%>%
  format_modelcompdat('classif1')
thresh_regr1 <- threshold_dat(bmres = rfbm_regr$bm_regr)%>%
  format_modelcompdat('regr1')
thresh_classif2 <- threshold_dat(bmres = rfeval_featsel$bm_classif) %>%
  format_modelcompdat('classif2')

format_modelcompdat(thresh_classif1, 'classif1')
format_modelcompdat(thresh_regr1, 'regr1')
format_modelcompdat(thresh_classif2, 'classif2') 

threshplot_datall <- rbindlist(list(thresh_classif1, thresh_regr1, thresh_classif2)) %>%
  .[, list(value_mean = mean(value)), by=.(threshold_class, variable, learner_format, selection)]


ggthresh_benchmark <- ggplot(threshplot_datall[variable %in% c('sens', 'spec'),],
                             aes(x=threshold_class, y=value_mean,
                                 linetype=variable,
                                 gourp=learner_format,
                                 color=learner_format)) +
  geom_line(size=1.2) +
  #scale_color_brewer(palette='Dark2') +
  scale_linetype(labels=c('Sensitivity (true positives)',
                          'Specificity (true negatives)')) +
  scale_x_continuous(expand=c(0,0), name='Threshold') +
  scale_y_continuous(expand=c(0,0), name='Value') +
  facet_wrap(~selection) + 
  theme_bw() + 
  theme(panel.spacing = unit(0.75, "cm"), 
        legend.title = element_blank())

ggthresh_benchmark
```

#Main text - Figure 2. Variable importance for top 20 variables
```{r variable importance, fig.width=12, echo=FALSE}
ggvimp(rftuned, predvars, varnum=20, spatial_rsp = FALSE)
```

#Main text - Figure 3. Partial dependence plots
```{r partial dependence, fig.width=12, fig.height=12, echo=FALSE}
pd_plot <- ggpd(rftuned, predvars, colnums=1:10, nodupli = TRUE,
                 ngrid = 20, parallel = T, spatial_rsp = FALSE)
lapply(pd_plot, plot)
```

#Methods - Figure 3 A. Predictions uncertainty by metavariable and environment
```{r prediction uncertainty by variable}
gguncertainty(in_rftuned = rftuned,
                                   in_gaugestats = gaugestats_format,
                                   in_predvars = predvars,
                                   spatial_rsp = FALSE)
```

#Main text - Figure 3 A. Geographic errors and uncertainty in predictions
```{r prediction uncertainty by geography, eval = FALSE}
loadd(gaugep)

#Get 
rsmp_res <- get_outerrsmp(rftuned, spatial_rsp=TRUE)
predsp <- rsmp_res$prediction() %>% 
  as.data.table %>%
  .[, list(IRpredprob_spcv = 100*mean(prob.1),
           IRpredcoefcv_spcv = sd(100*prob.1, na.rm=T)/mean(100*prob.1, na.rm=T)), 
    by=.(row_id, truth)] %>%
  .[, prederror := IRpredprob_spcv-100*as.numeric(as.character(truth))] %>%
  .[, prederror_abs := abs(prederror)] %>%
  .[, IRpedcat_spcv := as.character(fifelse(IRpredprob_spcv > 40, 1, 0))] %>%
  setorder(row_id) %>%
  cbind(gaugestats_format[!is.na(cly_pc_cav), list(GRDC_NO=GRDC_NO)]) 

predsp_gaugep <- merge(gaugep, predsp, by='GRDC_NO') %>%
  .[order(.[,'prederror_abs']$prederror_abs),]

qplot(predsp_gaugep$prederror)

p_pr <- ggrivers() + 
  geom_sf(data=predsp_gaugep, aes(color=IRpedcat_spcv), alpha=1) +
  scale_size_continuous(range=c(0.2, 2)) +
  coord_sf(datum = NA, expand=F,
           xlim=c(-17000000, 17000000), ylim=c(-7000000,8700000))
p_pr


#-------------- Kriging interpolation of errors --------------------------------
#Convert to SpatialPointDataFrame to use in gstats and project to Goode Homolosine
crs_aeqd <- "+proj=aeqd +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
predsp_gaugep_df <- st_transform(predsp_gaugep, crs=crs_aeqd)  %>%
  as_Spatial()
  
# Compute the sample variogram; note that the f.1 trend model is one of the
# parameters passed to variogram(). This tells the function to create the 
# variogram on the de-trended data.
var_smpl <- gstat::variogram(prederror ~ 1, predsp_gaugep_df, 
                             cutoff=50000, width=500, cressie=TRUE) #cloud=T)

ggplot(var_smpl, aes(x=dist, y=gamma)) + 
  geom_point(alpha=1/3) + 
  coord_cartesian(expand=F) +
  scale_y_log10() +
  theme_classic()

  # scale_x_sqrt(breaks=c(0,100,1000,10000,25000,50000, 100000),
  #              labels=c(0,100,1000,10000,25000,50000, 100000)) +

# Compute the variogram model by passing the nugget, sill and range values
# to fit.variogram() via the vgm() function.
varmods <- as.character(vgm()[,'short'])
dat_fit  <- fit.variogram(var_smpl, fit.ranges = TRUE, fit.sills = FALSE,
                          vgm(varmods[!(varmods %in% c('Pow', 'Int'))]), 
                          fit.kappa = TRUE)
# The following plot allows us to assess the fit
plot(var_smpl, dat_fit)

# Import gauge buffer mask
bufmask <- raster(bufras_vec[[1]]) %>%
  as('SpatialGrid')
  
  
#Predict error
kmod <- gstat(formula=prederror~1, locations=predsp_gaugep_df, model=dat_fit)
kp <- predict(kmod, bufmask)
## [using ordinary kriging]
spplot(kp)



# Plot the map
tm_shape(r.m) + 
  tm_raster(n=10, palette="RdBu", auto.palette.mapping=FALSE, 
            title="Predicted precipitation \n(in inches)") +
  tm_shape(P) + tm_dots(size=0.2) +
  tm_legend(legend.outside=TRUE)


predsp_over <- predsp_gaugep[predsp_gaugep$prederror > 0,] 
p_pr <- ggrivers() + 
  geom_sf(data=predsp_over, aes(color=IRpredprob_spcv, size=prederror_abs), alpha=1) +
  scale_color_distiller(palette='PuRd', direction = 1) +
  scale_size_continuous(range=c(0.2, 2)) +
  coord_sf(datum = NA, expand=F,
           xlim=c(-17000000, 17000000), ylim=c(-7000000,8700000))
p_pr


  scale_color_gradient(name='Years of data', low='#0F9FD6', high='#152540', 
                       breaks=c(min(perennial_gauges$totalYears_kept), 100, max(perennial_gauges$totalYears_kept))) +
  coord_sf(datum = NA, ylim=c(-7000000,8700000), expand=F) 


```

#Main text - Figure 3 B. Predictions for gauges and full network
```{r prediction maps - probability}
```
