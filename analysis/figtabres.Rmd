---
title: "figs_tabs_results"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Possible palettes #1: #538797, #C2D9CD, #FF842A https://www.instagram.com/p/B9En6h2gbJ5/
#Possible palette #2: #238189, #3FA8B3, #E8F3EE, #FF674D https://www.instagram.com/p/BxZZu82gBm3/


#File structure
rootdir <- rprojroot::find_root(rprojroot::has_dir("src")) 
srcdir <- file.path(rootdir, 'src', 'globalIRmap')
datdir <- file.path(rootdir, 'data')

#Source packages functions
library(drake)
source(file.path(srcdir, 'R/IRmapping_packages.R'))
source(file.path(srcdir, 'R/IRmapping_functions.R'))
source(file.path(srcdir, 'R/IRmapping_plan.R'))

#Get packages
library("rnaturalearth")
library("rnaturalearthdata")
library(rgeos)
library(rgdal)
library(cowplot)
library(maps)
library(patchwork)
#remotes::install_github("zeehio/facetscales")
library(facetscales)
library(scales)
library(kableExtra)

#Define paths
riveratlas_path <- file.path(datdir, 'HydroATLAS', 
                             'RiverATLAS_v10.gdb', 'RiverATLAS_v10') 

#Source analysis outputs
loadd(predvars)
loadd(filestructure)
loadd(gaugestats_format)

#Define Winkel Tripel projection
crs_wintri = "+proj=wintri +datum=WGS84 +no_defs +over"

#Get mapping
wcountries <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf")
wland <- rnaturalearth::ne_download(scale = 110, type = 'land', category = 'physical')
wlakes <- rnaturalearth::ne_download(scale = 110, type = 'lakes', category = 'physical')

sfformat_wintri <- function(in_sp) {
  return(st_as_sf(in_sp) %>%
           st_transform("+proj=wintri", use_gdal = FALSE)
)
}

#Create winkel tripel graticule
grat_wintri <- 
  st_graticule(lat = c(-89.9, seq(-80, 80, 20), 89.9)) %>%
  st_transform(crs = crs_wintri)

#---- Import and format river network lines, keeping a subset of columns and only for river orders > 4 --------
riv_query <- "SELECT HYRIV_ID, ORD_STRA, dis_m3_pyr FROM \"RiverATLAS_v10\" WHERE ORD_STRA > 4"
riv_lines <- st_read(dsn = dirname(riveratlas_path), 
                      layer = basename(riveratlas_path),
                      query = riv_query)

riv_wintri <- sfformat_wintri(riv_lines)
riv_simple <-  sf::st_simplify(riv_wintri, preserveTopology = TRUE, dTolerance = 1000)

#---- Import and format streamgauges --------
gaugepred <- st_read(filestructure['out_gauge']) %>%
  sfformat_wintri

#---- Import and format river network attributes ------------------------------
cols_tokeep <-  c("HYRIV_ID", predvars[!is.na(ID),varcode],
                  'ele_mt_cav','ele_mt_uav', 'gwt_cm_cav',
                  paste0('pre_mm_c', str_pad(1:12, width=2, side='left', pad=0)),
                  paste0('cmi_ix_c', str_pad(1:12, width=2, side='left', pad=0)),
                  paste0('swc_pc_c', str_pad(1:12, width=2, side='left', pad=0)))

riveratlas <- fread_cols(filestructure['in_riveratlas'], 
                         cols_tokeep = cols_tokeep) %>%
  comp_derivedvar

```


#Figure 1. Geographical distribution of reference streamgauging stations
```{r basic map, echo = FALSE, fig.width = 6,  dpi=300}
ggrivers <- function() {
    ggplot() +
    geom_sf(data = grat_wintri, color = alpha("black", 1/5), size = 0.25/.pt) + 
    geom_sf(data=sfformat_wintri(wland), alpha=1/2, color=NA) +
    geom_sf(data=sfformat_wintri(wlakes),  alpha=1/3, fill='black', color=NA) +
    geom_sf(data=riv_simple[riv_simple$ORD_STRA < 6,][1:10000,],
            aes(size=ORD_STRA), color=alpha('black', 1/20), show.legend = F) +
    geom_sf(data=riv_simple[riv_simple$ORD_STRA >= 6,][1:10000,],
            aes(size=ORD_STRA), color=alpha('black', 1/10), show.legend = F) +
    scale_size_continuous(range=c(0.2, 1.0)) +
    coord_sf(datum = NA, ylim=c(-7000000,8700000), expand=F) +
    theme_map() + 
    theme(legend.position=c(0.1,0),
          legend.direction="horizontal",
          legend.text = element_text(size=12),
          legend.title = element_text(size=12),
          legend.key.height = unit(0.1,"in"))
}

perennial_gauges <- gaugepred[gaugepred$intermittent=='0',]
p_pr <- ggrivers() + 
  geom_sf(data=perennial_gauges, aes(color=totalYears_kept), size=1, alpha=0.8) +
  scale_color_gradient(name='Years of data', low='#0F9FD6', high='#152540', 
                       breaks=c(min(perennial_gauges$totalYears_kept), 100, max(perennial_gauges$totalYears_kept))) +
  coord_sf(datum = NA, ylim=c(-7000000,8700000), expand=F) 

ir_gauges <-  gaugepred[gaugepred$intermittent=='1',]
p_ir <- ggrivers() + 
  geom_sf(data=ir_gauges, aes(color=totalYears_kept), size=1, alpha=0.8) +
  scale_color_gradient(name='Years of data', low='#ff9b52', high='#a32d18', 
                       breaks=c(min(ir_gauges$totalYears_kept), 100, max(ir_gauges$totalYears_kept))) +
  coord_sf(datum = NA, ylim=c(-7000000,8700000), expand=F)

p_pr/p_ir

```

#Environmental variables used in model training
```{r variable figure, echo=FALSE } 
predvars[varcode=='dis_mm_pvar', `:=`(
  Category = 'Hydrology',
  Attribute= 'Natural Discharge',
  `Spatial representation`='p',
  `Temporal/Statistical aggreg.`='mn/mx',
  Source = 'WaterGAP v2.2',
  Citation = 'Döll et al. 2003'
)]

predvars[varcode=='dis_mm_pvaryr', `:=`(
  Category = 'Hydrology',
  Attribute= 'Natural Discharge',
  `Spatial representation`='p',
  `Temporal/Statistical aggreg.`='mn/yr',
  Source = 'WaterGAP v2.2',
  Citation = 'Döll et al. 2003'
)]

predvars[varcode=='ele_pc_rel', `:=`(
  Category = 'Physiography',
  Attribute= 'Elevation',
  `Spatial representation`='c',
  `Temporal/Statistical aggreg.`='(cav-uav)/uav',
  Source = 'EarthEnv-DEM90',
  Citation = 'Robinson et al. 2014'
)]


predvars[varcode=='pre_mm_cvar', `:=`(
  Category = 'Climate',
  Attribute= 'Precipitation',
  `Spatial representation`='c',
  `Temporal/Statistical aggreg.`='mn/mx',
  Source = 'WorldClim v1.4',
  Citation = 'Hijmans et al. 2005'
)]

oldcolnames <- c('Spatial.representation',
                 'Temporal.or.statistical.aggregation.or.other.association',
                 'Source Data')
newcolnames <- c('Spatial representation',
             'Temporal/Statistical aggreg.',
             'Source')

predvars_format <- copy(predvars) %>%
  setnames(oldcolnames, newcolnames) %>%
  setorder(Category, Attribute, 
           `Spatial representation`, `Temporal/Statistical aggreg.`)

######## ADD variable importance, ranking, and p-value#######################################
#loadd(rfeval_featsel)
#bm_classif$vimp
#predvars_format <- merge(predvars_format, predvars_format, by.x= 'varcode', by.y='varnames']


kable(predvars_format[,c('Category', 'Attribute', 
                         newcolnames, 'Citation'), with=F]) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

#Figure 2. Environmental distribution of reference streamgauging stations
Bernhard, is dor_pc_pva x 100 rather than x10 (as written in doc)?
```{r envdistrib, fig.width = 6, fig.height=6, dpi=300, message=FALSE}
#Radar plot of selected variables
#names(riveratlas)

varstoplot_hist <- c("ari_ix_uav", "cly_pc_uav", "clz_cl_cmj", "cmi_ix_uyr", 
                      "dis_m3_pyr", "dor_pc_pva","for_pc_use", "gla_pc_use", 
                     "kar_pc_use", "lka_pc_use", "pet_mm_uyr", "snw_pc_uyr", 
                     "run_mm_cyr", "swc_pc_uyr", "tmp_dc_uyr", "hdi_ix_cav",
                     "hft_ix_c93", "ORD_STRA", "gwt_m_cav",  "ire_pc_use")

formatscales <- function(in_df, varstoplot) {
  scales_x <- list(
    ari_ix_uav = scale_x_continuous(),
    cly_pc_uav = scale_x_continuous(labels=percent_format(scale=1)),
    clz_cl_cmj = scale_x_continuous(limits=c(1,18), expand=c(0,0),
                                    breaks=seq(0,18,2)),
    cmi_ix_uyr = scale_x_continuous(),
    dis_m3_pmn = scale_x_sqrt(breaks=c(0, 10^(0:log10(max(in_df$dis_m3_pmn)))),
                              labels=c(0, 10^(0:log10(max(in_df$dis_m3_pmn))))),
    dis_m3_pyr = scale_x_sqrt(breaks=c(0, 10^(0:log10(max(in_df$dis_m3_pmn)))),
                              labels=c(0, 10^(0:log10(max(in_df$dis_m3_pmn))))),
    dor_pc_pva = scale_x_continuous(labels=percent_format(scale=1)),
    for_pc_use = scale_x_continuous(labels=percent_format(scale=1)),
    gla_pc_use = scale_x_continuous(labels=percent_format(scale=1)),
    gwt_m_cav = scale_x_continuous(), #Change that to gwt_m_cav
    inu_pc_umn = scale_x_continuous(labels=percent_format(scale=1)),
    ire_pc_use = scale_x_continuous(labels=percent_format(scale=1)),
    kar_pc_use = scale_x_continuous(labels=percent_format(scale=1)),
    lka_pc_use = scale_x_continuous(labels=percent_format(scale=1)),
    pet_mm_uyr = scale_x_continuous(), 
    snw_pc_uyr = scale_x_continuous(labels=percent_format(scale=1)),
    run_mm_cyr = scale_x_continuous(),
    swc_pc_uyr = scale_x_continuous(labels=percent_format(scale=1)),
    tmp_dc_uyr = scale_x_continuous(),
    hdi_ix_cav = scale_x_continuous(),
    hft_ix_c09 = scale_x_continuous(),
    ORD_STRA = scale_x_continuous()
  )
  
  scales_y <- unlist(rep(list(scale_y_log10(expand=c(0,0))), labels = scientific_format(),
                         length(scales_x)), 
                     recursive=F) %>%
    setNames(names(scales_x))
  scales_y[['dis_m3_pmn']] <- scale_y_sqrt(expand=c(0,0))
  
  coordcart <- lapply(varstoplot_hist, function(var) {
    coord_cartesian(xlim=as.data.table(in_df)[, c(min(get(var)), max(get(var)))])
  }) %>%
    setNames(names(scales_x))
  coordcart[['clz_cl_cmj']] <-  coord_cartesian(
    xlim=c(1,max(in_df$clz_cl_cmj)))
  
  
  return(list(scales_x=scales_x, scales_y=scales_y, coordcart=coordcart))
}

scalesenvhist <- formatscales(riveratlas, varstoplot)


ggenvhist <- function(vartoplot, in_gaugedt, in_rivdt, in_predvars, intermittent=TRUE) {
  print(vartoplot)
  if (intermittent) {
    vartoplot2 <- c(vartoplot, 'intermittent')
  }
  
  varname <- in_predvars[varcode==vartoplot, paste0(Attribute, ' ', 
                                                    Keyscale, 
                                                    Keystat, 
                                                    ' (',unit,')')]
  gaugeformat <- as.data.table(in_gaugedt)[, `:=`(
    ari_ix_cav = ari_ix_cav/100,
    ari_ix_uav = ari_ix_uav/100,
    cmi_ix_cmn = cmi_ix_cmn/100,
    cmi_ix_uyr = cmi_ix_uyr/100,
    dor_pc_pva = dor_pc_pva/100,
    lka_pc_cse = lka_pc_cse/10,
    lka_pc_use = lka_pc_use/10,
    tmp_dc_cmn =  tmp_dc_cmn/10,
    tmp_dc_cmx =  tmp_dc_cmx/10,
    tmp_dc_cyr =  tmp_dc_cyr/10,
    tmp_dc_uyr =  tmp_dc_uyr/10,
    gwt_m_cav = gwt_cm_cav/100
  )] %>%
    .[, vartoplot2, with=F] 
  
  rivformat <- as.data.table(in_rivdt)[, vartoplot, with=F]
  
  penvhist <- ggplot(gaugeformat, aes_string(x=vartoplot)) +
    geom_histogram(data=rivformat, bins=20, fill='lightgray') + 
    geom_histogram(bins=20, fill='darkgray') +
    #aes(fill=intermittent), position = 'stack') - doesn't work with log or sqrt y scale
    # scale_fill_manual(values=c('#0F9FD6','#ff9b52'), 
    #                   labels = c('Perennial', 'Intermittent'), name=NULL) +
    scalesenvhist$scales_x[[vartoplot]] +
    scalesenvhist$scales_y[[vartoplot]] +
    scalesenvhist$coordcart[[vartoplot]] +
    xlab(varname) +
    ylab('Count') +
    theme_classic() + 
    theme(strip.background=element_rect(colour="white", fill='lightgray'),
          axis.title.y = element_blank(),
          axis.title = element_text(size=12))
  

  if (which(vartoplot %in% varstoplot_hist)!=length(varstoplot_hist)) {
    penvhist <- penvhist + 
      theme(legend.position='none')
  }

  return(ggplotGrob(penvhist)) 
}

penvhist_grobs <- lapply(varstoplot_hist, ggenvhist, 
                         in_gaugedt = gaugepred, 
                         in_rivdt = riveratlas,
                         in_predvars=predvars)
do.call("grid.arrange", list(grobs=penvhist_grobs))
```


Figure 3. Benchmark comparison of models: spatial and non-spatial cross-validation results. Balanced accuracy (including post-analysis pseudo bacc for regression RF), Brier’s score
```{r models benchmarking, echo=FALSE}

#Set of box plots with annotations comparing algorithms and 
#with vs. without feature selection in terms of performance
#and time to run, and including spatial vs non-spatial. 

#Set of threshold analysis (ROC curves)
cached()
bmcheck_classif <- readd(bm_checked_rfbm_classif.bm_classif_rfbm_classif.measure_classif)
bmcheck_regr <- readd(bm_checked_rfbm_regr.bm_regr_rfbm_regr.meassure_regr)
loadd(rfbm_classif)
loadd(rfbm_regr)
loadd(rfeval_featsel)


bp_classif1 <- bmcheck_classif$bm_boxcomp$data %>%
  .[, `:=`(cat = 'Algorithm selection',
           type = 'Classification RF')]
bp_regr1 <- bmcheck_regr$bm_boxcomp$data %>%
  .[, `:=`(cat = 'Algorithm selection',
           type = 'Regression RF')]
bp_classif2 <- rfeval_featsel$bm_analysis$bm_boxcomp$data %>%
  .[, `:=`(cat = 'Predictor selection',
           type = 'Classification RF')]
bp_dat <- rbindlist(list(bp_classif1, bp_regr1, bp_classif2), fill=TRUE)

rsmp_bbrier <- function(bmres, rsmp_i) {
  rsmp <- bmres$resample_result(rsmp_i)
  rsmp_pred<- rsmp$prediction()
  if (inherits(rsmp_pred, 'PredictionClassif')) {
    bbrier <- sum((as.numeric(as.character(rsmp_pred$truth)) -
                     rsmp_pred$prob[,'1'])^2)/length(rsmp_pred$row_ids)
  }

  if (inherits(rsmp_pred, 'PredictionRegr')) {
    bbrier <- sum((as.numeric(as.character(rsmp_pred$truth)) -
                     rsmp_pred$response)^2)/length(rsmp_pred$row_ids)
  }
  return(bbrier)
}

rsmp_auc <- function(bmres, rsmp_i) {
  rsmp <- bmres$resample_result(rsmp_i)
  rsmp_pred<- rsmp$prediction()
  auc <- Metrics::auc(rsmp_pred$truth, rsmp_pred$response)
  return(auc)
}

rsmp_bacc <- function(bmres, rsmp_i, threshold_class) {
  rsmp <- bmres$resample_result(rsmp_i)
  rsmp_pred <- rsmp$prediction()

  if (inherits(rsmp_pred, 'PredictionClassif')) {
    prob_resp <- rsmp_pred$prob[,'1']
  }
  if (inherits(rsmp_pred, 'PredictionRegr')) {
    prob_resp <- rsmp_pred$response
  }

  response <- as.data.table(prob_resp)[
    , c(fifelse(prob_resp>=threshold_class, '1', '0'))]

  bacc <- mlr3measures::bacc(factor(as.character(rsmp_pred$truth),
                                    levels=c('0', '1')),
                             factor(response, levels=c('0','1')))
  return(data.table(bacc=bacc, threshold_class=threshold_class))
}

bm_paramstime <- function(bmres) {
  lrns_dt <- as.data.table(bmres$data)

  ##############################################################################
  params_format <- lapply(lrns_dt$learner, function(lrn) {
    print(lrn$id)
    #Get general parameters-----------------------------------------------------
    if (inherits(lrn ,'AutoTuner')) {
      lrn_in <- lrn$learner
    } else {
      lrn_in <- lrn
    }

    #If GraphLearner, get parameters for each Pipe Operator
    if (inherits(lrn_in, 'GraphLearner')) {
      paramtab <- lapply(lrn_in$graph$pipeops, function(po) {
        #Get default params
        def <- as.data.table(po$param_set$default) %>%
          .[, po_id := po$id] %>%
          melt(id.var='po_id')

        #Get set param
        value <- as.data.table(po$param_set$values) %>%
          .[, po_id := po$id]%>%
          melt(id.var='po_id')

        #Merge default and set params, keeping set ones when present
        if (ncol(def)==1) {
          graphparams <- value
        } else if (ncol(value)==1) {
          graphparams <- def
        } else {
          graphparams <- merge(def, value[, .(variable, value, po_id)],
                               by=c('po_id', 'variable'),
                               all.x=T, all.y=T) %>%
            .[is.na(value.y), value.y := value.x] %>%
            setnames('value.y', 'value') %>%
            .[, value.x := NULL] %>%
            .[, variable := gsub('[.]', '', variable)] %>%
            unique(by='variable')
        }
        return(graphparams)
      }) %>%
        rbindlist(use.names=TRUE)

    #If direct learner
    } else {
      #Get default params
      def <- as.data.table(lrn_in$param_set$default) %>%
        melt(id.vars=integer())

      #Get set param
      value <- as.data.table(po$param_set$values) %>%
        melt(id.vars=integer())

      #Merge default and set params, keeping set ones when present
      paramtab <- merge(def, value, by='variable', all.x=T, all.y=T) %>%
        .[is.na(value.y), value.y := value.x] %>%
        setnames('value.y', 'value') %>%
        .[, value.x := NULL] %>%
        .[, variable := gsub('[.]', '', variable)] %>%
        unique(by='variable') #Models are not consistent in their use of dots
    }

    #Get inner sampling parameters----------------------------------------------
    if ('instance_args' %in% names(lrn)) {
      param_ranges <- as.list(
        paste0(lrn$instance_args$param_set$lower,
               '-',
               lrn$instance_args$param_set$upper))
      names(param_ranges) <- lrn$instance_args$param_set$ids()


      inner_smp  <- cbind(
        as.data.table(
          lrn$instance_args$resampling$param_set$get_values()),
        as.data.table(
          lrn$instance_args$terminator$param_set$get_values())
      ) %>%
        .[, nruns := prod(.SD)] %>%
        setnames(names(.), paste0('inner_', names(.))) %>%
        cbind(as.data.table(param_ranges))

      #If no inner sampling
    } else {
      inner_smp <- data.table(inner_nruns = 1)
    }


    #Remove pipe operator names and dot from names (inconsistent use across learners)
    setnames(inner_smp,
             old=names(inner_smp),
             new=gsub('[.]', '',
                      gsub(paste(paste0('(', unique(paramtab$po_id), '[.]*)'),
                                 collapse = '|'),
                           '',
                           names(inner_smp))))

    #---------------------------------------------------------------------------
    #Merge inner sampling parameters and general parameters, then format
    return(
      paramtab %>%
      .[!(variable %in% names(inner_smp)),] %>%
      dcast(.~variable, value.var='value') %>%
      cbind(inner_smp)
    )
  }) %>%
    rbindlist(., fill=T)
  ##############################################################################

  #Get task, learner and resampling ids
  lrns_time <- cbind(lrns_dt, params_format) %>%
    .[, learner_id := unlist(lapply(learner, function(x) x$id))] %>%
    .[, task_id := unlist(lapply(task, function(x) x$id))] %>%
    .[, resampling_id := unlist(lapply(resampling, function(x) x$id))]
  
  #Get number of features
  lrns_time[, npredictors := 
              lapply(lrns_dt$task,function(x) length(x$feature_names)) %>%
              unlist] 
  
  #Compute train and predict time by learner, task and resampling
  bm_ttot <- as.data.table(bmres$aggregate(list(msr('time_train'),
                                                msr('time_predict')))) %>%
    .[lrns_time, on=c('learner_id', 'task_id', 'resampling_id')] %>%
    unique(by='nr') %>%
    .[, time_train := time_train/inner_nruns]

  return(bm_ttot)
}

bm_msrtab <- function(bmres) {
  bbrier_vec <- lapply(1:bmres$n_resample_results, function(i) {
    rsmp_bbrier(bmres=bmres, rsmp_i=i)
  }) %>%
    unlist

  auc_vec <- lapply(1:bmres$n_resample_results, function(i) {
    rsmp_auc(bmres=bmres, rsmp_i=i)
  }) %>%
    unlist

  outer_smp <- lapply(bmres$resamplings$resampling, function(rsmp_design) {
    as.data.table(rsmp_design$param_set$get_values()) %>%
      setnames(names(.), paste0('outer_', names(.))) %>%
      .[, resampling_id := rsmp_design$id]
  }) %>%
    rbindlist(use.names=T)

  bacc_vec <- lapply(1:bmres$n_resample_results, function(i) {
    baccthresh <- ldply(seq(0,1,0.01), function(threshold_class) {
      rsmp_bacc(bmres, rsmp_i=i, threshold_class=threshold_class)}) %>%
      setorder(bacc) %>%
      setDT %>%
      .[, .SD[.N, .(bacc, threshold_class)]]
  }) %>%
    rbindlist

  #Get inner sampling params, general params, and time
  params_time_dt <- bm_paramstime(bmres)

  #Get time and add to bbrier
  moddt <- bm_paramstime(bmres) %>%
    cbind(., outer_smp) %>%
    cbind(., bacc_vec) %>%
    .[,`:=`(bbrier = bbrier_vec,
            auc = auc_vec)]

  return(moddt)
}

tbbrier_classif1 <- bm_msrtab(rfbm_classif$bm_classif) %>%
  .[, `:=`(cat = 'Algorithm selection',
           type = 'Classification')]  %>%
  .[, learner_format := dplyr::case_when(
    learner_id == 'classif.ranger.tuned'~'default RF',
    learner_id == 'oversample.classif.ranger.tuned'~'default RF - oversampled',
    learner_id == 'classweights.classif.ranger.tuned'~'default RF - weighted classes',
    learner_id == 'classif.cforest'~'CIF',
    learner_id == 'oversample.classif.cforest'~'CIF - oversampled',
    learner_id == 'classweights.classif.cforest'~'CIF - weighted classes',
  )]

tbbrier_regr1 <- bm_msrtab(rfbm_regr$bm_regr) %>%
  .[, `:=`(cat = 'Algorithm selection',
           type = 'Regression')] %>%
  .[, learner_format := dplyr::case_when(
    task_id == 'inter_regr' ~'MAXSTAT',
    task_id == 'inter_regrover' ~'MAXSTAT - oversampled'
  )]

tbbrier_classif2 <- bm_msrtab(rfeval_featsel$bm_classif) %>%
  .[, `:=`(cat = 'Predictor selection',
           type = 'Classification')] %>%
  .[, learner_format := dplyr::case_when(
    task_id == 'inter_basicsp' ~ 'default RF - oversampled - all variables',
    task_id == 'inter_basicsp_featsel' ~ 'default RF - oversampled - selected variables'
  )]

metrics_dat <- rbindlist(list(tbbrier_classif1, tbbrier_regr1, tbbrier_classif2),
                         fill = TRUE, use.names = TRUE)





ggplot(bp_classif, aes(x=interaction(task_id, learner_id), y=classif.bacc)) +
  geom_boxplot() +
  facet_wrap(~cat, scales='free_x') +
  theme_classic()













bp_classif2 <- plot(rfeval_featsel$bm_analysis$bm_boxcomp)
bp_regr <- plot(bmcheck_regr$bm_boxcomp)
  
  
  
  plot(bmcheck_classif$bm_misclasscomp)


plot(bmcheck_classif$bm_boxcomp)
plot(rfeval_featsel$bm_analysis$bm_misclasscomp)
plot(rfeval_featsel$bm_analysis$bm_boxcomp)


plot(bmcheck_regr$bm_misclasscomp)
plot(bmcheck_regr$bm_boxcomp)




as.data.table(rfbm_classif$bm_classif$aggregate(msr('time_both')))
as.data.table(rfbm_classif$bm_classif$aggregate(msr('classif.acc')))
as.data.table(rfbm_classif$bm_classif$aggregate(msr('classif.bacc')))
as.data.table(rfbm_classif$bm_classif$aggregate(msr('classif.auc')))

#Check time with featset

#Table with name of model, reference, parameters tested, 
#time to run, performance (first round, just CV), # of features
#with multiple levels (one for initial selection, the other for feature selection) (second, CV + spCV)





#Remove legends in bm_misclasscom
legend <- gg_grod$grobs[[15]]; 
# Make b pink; 
legend$grobs[[1]]$grobs[[7]]$gp$col <- "pink";
legend$grobs[[1]]$grobs[[8]]$gp$col <- "pink"; 
# Remove a; 
legend$grobs[[1]]$grobs[3:5] <- list(nullGrob(), nullGrob(), nullGrob())
```

Figure 4. Variable importance for top 20 variables + variable selection results

Table S1. Variable selection benchmarking results



